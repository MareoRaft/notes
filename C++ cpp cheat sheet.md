My current state of knowledge of C++11 expressions, summarized into my own cheat sheet (excluding concepts regarding C++ classes):  1a) Every expression has a type (e.g. int, double&, char&&).   1b) Every expression has a value category (i.e. lvalue vs. rvalue).  2a) Every lvalue [expression] has an address. 2b) Every lvalue [expression] has a size. Compliant C++ compilers require size is always positive.  3) Every expression composed of a single named entity is an lvalue (e.g. variable names, function names).  4a) Every lvalue reference is itself an lvalue [expression] (through the alias property). 4b) The address of an lvalue reference is the address of its referee. 4c) The sizeof an lvalue reference is the sizeof its referee.  5a) Non-const lvalues (e.g. non-const variables) can be used to modify their respective storage. 5b) Lvalue references of non-const types may only refer to non-const lvalues (consistent with both the const qualifier and the alias property).  6a) Const lvalues (e.g. functions) cannot be used to modify their respective storage. 6b) Lvalue references of const types are themselves const lvalues. 6c) Lvalue references of const types may refer to any lvalue despite the lvalue’s constness (consistent with the alias property). 6d) Lvalue references to const types may refer to any rvalue (in which case it actually refers to storage in memory that is initialized from the rvalue).  7a) Rvalue references may refer to rvalues. 7b) Named rvalue references (e.g. variables with type rvalue reference) are themselves lvalues (since all variables are named and hence lvalues by property 3). 7c) Unnamed rvalue references (e.g. expressions that cast a non-reference variable to an rvalue reference) are themselves rvalues.  8a) [Copy Semantics] Assigning an lvalue reference or a non-const non-reference expression to a non-const non-reference lvalue shall preserve the former when constructing the latter. The latter is constructed as a copy of the former. Construction of latter depends on its type, especially whether it is a primitive type or a class type. (Prerequisites: Classes, Constructors) 8b) [Move Semantics] Assigning an rvalue reference to a non-reference lvalue may alter the former’s referee when constructing the latter. Since the former’s referee represents a temporary value, the latter is constructed as a movement of the former’s referee, leaving the former’s referee in a possibly-altered state. Construction of latter depends on its type, especially whether it is a primitive type or a class type. (Prerequisites: Classes, Constructors)  9a) [Reference Collapsing] (Prerequisites: Templates) 9b) [Variadic Templates] (Prerequisites: Templates, Parameter Packs) 9c) [Perfect Forwarding] (Prerequisites: Reference Collapsing, Variadic Templates)